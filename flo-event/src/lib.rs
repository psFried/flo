//! This crate defines the common types that form the basic building blocks of flo, events.
//! An Event is exactly what it sounds like. Semantically, it describes something that _happened_. Events are fundamentally
//! different than typical _domain objects_, which are focused on _state_.
//!
//! Events are also persistent. Many consumers can _consume_ the same event, and a single consumer can even go back and
//! read the same event multiple times if it chooses to. This makes an event stream much more efficient that queue-based
//! topics in situations with many consumers.
//!
//! Flo allows each event to declare a namespace. By convention, the namespaces of events describe the hierarchy within the
//! domain. Consider the example of modeling the operations in a restaurant. The namespaces in your domain might look
//! something like:
//!
//! <pre>
//! restaurant/
//!    ├── dining-room
//!    │   ├── bar
//!    │   └── tables
//!    │       ├── 1
//!    │       ├── 2
//!    │       └── 3
//!    ├── kitchen
//!    │   ├── dishwasher
//!    │   ├── fridge
//!    │   └── oven
//!    └── staff
//!        ├── Jen
//!        └── Robbie
//! </pre>
//! So, an event pertaining to the dishwasher would be in the namespace `/restaurant/kitchen/dishwasher`, while an event
//! related just to table 1 would be in `/restaurant/dining-room/tables/1`. If a consumer was interested in events
//! related to _all tables_, then they would read events from `/restaurant/dining-room/tables/*`, or if they were interested
//! in all events in the dining room, whether at a table or at the bar, they could consume events from
//! `/restaurant/dining-room/**/*`. This allows application services to be appropriately scoped, while still giving then
//! the freedom to cross-cut concerns. For instance, we might want to deploy a monitoring service to collect performance
//! statistics on the entire system. That monitoring service would surely want to get every event, so could read events
//! from `/**/*`.
//!
extern crate chrono;
extern crate crc;
extern crate byteorder;

pub mod time;
mod id;
mod version_vec;
mod crc_error;

pub use self::crc_error::InvalidCrcError;
pub use version_vec::VersionVector;
pub use id::*;

use std::fmt::Debug;
use chrono::{DateTime, Utc};

/// All event timestamps are non-monotonic UTC timestamps with millisecond precision. Although the chrono crate can represent
/// nanosecond precision, this resolution is not preserved by flo's wire protocol.
pub type Timestamp = DateTime<Utc>;


/// Defines an event from a client's perspective. An event Consists of some specific header information followed by
/// an optional section of binary data. Flo imposes no restrictions or opinions on what can be contained in the `data`
/// section.
pub trait FloEvent: Debug + EventData {
    /// The primary key of the event. This is immutable and never changes.
    fn id(&self) -> &FloEventId;
    /// The UTC timestamp (generated by the server) when this event was persisted.
    fn timestamp(&self) -> Timestamp;
    /// Events may optionally have a parent id. This is used to correlate events. A simple example would be a request/response
    /// where the response has it's `parent_id` set to the `id` of the request. It can also be used to trace events through a
    /// complex system of microservices. Clients are encouraged to keep it simple and just always set the `parent_id` to
    /// the `id` of whichever event is being processed at the time.
    fn parent_id(&self) -> Option<FloEventId>;
    /// Every event is produced to a namespace. Technically, this value can be any valid utf-8 string (except for newline `\n`
    /// characters). By convention, the namespace is a hierarchical path separated by forward slash `/` characters. This
    /// allows consumers to read events from multiple namespaces simultaneously by using glob syntax.
    fn namespace(&self) -> &str;
    /// Returns the total length of the data associated with this event.
    fn data_len(&self) -> u32;
    /// Returns the arbitrary binary data associated with this event.
    fn data(&self) -> &[u8];
    /// Converts this event into an `OwnedFloEvent`, cloning it in the process.
    fn to_owned_event(&self) -> OwnedFloEvent {
        let id = *self.id();
        let data = self.data().to_owned();
        let parent_id = self.parent_id();
        let timestamp = self.timestamp();
        let namespace = self.namespace().to_owned();
        OwnedFloEvent::new(id, parent_id, timestamp, namespace, data)
    }

}

pub trait EventData {
    fn event_namespace(&self) -> &str;
    fn event_parent_id(&self) -> Option<FloEventId>;
    fn event_data(&self) -> &[u8];

    fn get_precomputed_crc(&self) -> Option<u32>;

    /// Returns the CRC for this event, which is a CRC32C of the following fields in order:
    /// 
    /// - `namespace`
    /// - `parent_id`
    /// - `data`
    /// 
    /// This CRC does _not_ use the timestamp or the `id`
    fn compute_data_crc(&self) -> u32 {
        use crc::crc32::{update, CASTAGNOLI_TABLE};
        use byteorder::{ByteOrder, BigEndian};

        fn update_hash(value: u32, bytes: &[u8]) -> u32 {
            update(value, &CASTAGNOLI_TABLE, bytes)
        }

        // start with the crc of the parent id
        let mut value: u32 = {
            update_hash(0, self.event_namespace().as_bytes())
        };

        // convert the parent id to a consistent binary representation
        {
            let mut parent_id_bytes = [0u8; 11];
            let parent_id = self.event_parent_id();
            if parent_id.is_some() {
                let id = parent_id.as_ref().unwrap();
                parent_id_bytes[0] = 1;
                BigEndian::write_u64(&mut parent_id_bytes[1..9], id.event_counter);
                BigEndian::write_u16(&mut parent_id_bytes[9..], id.actor);
            }
            value = update_hash(value, &parent_id_bytes);
        }

        // finally, the data
        update_hash(value, self.event_data())
    }

    fn validate_crc(&self) -> Result<(), InvalidCrcError> {
        self.get_precomputed_crc().map(|crc| {
            let computed = self.compute_data_crc();
            if crc == computed {
                Ok(())
            } else {
                Err(InvalidCrcError{
                    computed,
                    actual: crc,
                })
            }
        }).unwrap_or(Ok(()))
    }

    fn get_or_compute_crc(&self) -> u32 {
        self.get_precomputed_crc().unwrap_or_else(|| self.compute_data_crc())
    }
}

pub struct BorrowedEventData<'a> {
    pub namespace: &'a str,
    pub parent_id: Option<FloEventId>,
    pub data: &'a [u8],
}

impl <'a> EventData for BorrowedEventData<'a> {
    fn event_namespace(&self) -> &str {
        self.namespace
    }

    fn event_parent_id(&self) -> Option<FloEventId> {
        self.parent_id
    }

    fn event_data(&self) -> &[u8] {
        self.data
    }
    fn get_precomputed_crc(&self) -> Option<u32> {
        None
    }
}

impl <T> FloEvent for T where T: AsRef<OwnedFloEvent> + Debug + EventData {
    fn id(&self) -> &FloEventId {
        &self.as_ref().id
    }

    fn timestamp(&self) -> Timestamp {
        self.as_ref().timestamp
    }

    fn parent_id(&self) -> Option<FloEventId> {
        self.as_ref().parent_id
    }

    fn namespace(&self) -> &str {
        self.as_ref().namespace.as_str()
    }

    fn data_len(&self) -> u32 {
        self.as_ref().data.len() as u32
    }

    fn data(&self) -> &[u8] {
        self.as_ref().data.as_slice()
    }

    fn to_owned_event(&self) -> OwnedFloEvent {
        self.as_ref().clone()
    }
}

impl AsRef<OwnedFloEvent> for OwnedFloEvent {
    fn as_ref(&self) -> &OwnedFloEvent {
        self
    }
}

/// This is the main `FloEvent` implementation that clients will deal with. All of the fields returned by the `FloEvent`
/// methods are simply owned fields in this struct.
#[derive(Debug, PartialEq, Clone)]
pub struct OwnedFloEvent {
    pub id: FloEventId,
    pub timestamp: Timestamp,
    pub parent_id: Option<FloEventId>,
    pub namespace: String,
    pub data: Vec<u8>,
    pub crc: u32,
}

impl OwnedFloEvent {
    pub fn new(id: FloEventId, parent_id: Option<FloEventId>, timestamp: Timestamp, namespace: String, data: Vec<u8>) -> OwnedFloEvent {
        let crc = {
            BorrowedEventData {
                parent_id,
                namespace: namespace.as_str(),
                data: data.as_slice()
            }.compute_data_crc()
        };
        OwnedFloEvent {
            id,
            timestamp,
            parent_id,
            namespace,
            data,
            crc
        }
    }

    pub fn validate_crc(&self) -> Result<(), u32> {
        let computed = self.compute_data_crc();
        if self.crc == computed {
            Ok(())
        } else {
            Err(computed)
        }
    }
}

impl <T> EventData for T where T: AsRef<OwnedFloEvent> {
    fn event_namespace(&self) -> &str {
        self.as_ref().namespace.as_str()
    }

    fn event_parent_id(&self) -> Option<FloEventId> {
        self.as_ref().parent_id
    }

    fn event_data(&self) -> &[u8] {
        self.as_ref().data.as_slice()
    }
    fn get_precomputed_crc(&self) -> Option<u32> {
        Some(self.as_ref().crc)
    }
}

